{"ast":null,"code":"/**\n * @import {Element, Nodes, RootContent, Root} from 'hast'\n * @import {Info, Schema} from 'property-information'\n */\n\n/**\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n */\n\n/**\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n */\n\n/**\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n */\n\n/**\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\n/**\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n */\n\n/**\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n */\n\n/**\n * @typedef {Record<string, PropertyValue | Style>} Properties\n *   Acceptable value for element properties.\n */\n\n/**\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n */\n\n/**\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n */\n\n/**\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n */\n\nimport { parse as parseCommas } from 'comma-separated-tokens';\nimport { parseSelector } from 'hast-util-parse-selector';\nimport { find, normalize } from 'property-information';\nimport { parse as parseSpaces } from 'space-separated-tokens';\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined;\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node;\n    if (selector === null || selector === undefined) {\n      node = {\n        type: 'root',\n        children: []\n      };\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */properties;\n      children.unshift(child);\n    } else {\n      node = parseSelector(selector, defaultTagName);\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase();\n      const adjusted = adjust ? adjust.get(lower) : undefined;\n      node.tagName = adjusted || lower;\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties);\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value);\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child);\n    }\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n    return node;\n  }\n  return h;\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true;\n  }\n\n  // Never node without `type`; thatâ€™s the main discriminator.\n  if (typeof value.type !== 'string') return false;\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */value;\n  const keys = Object.keys(value);\n  for (const key of keys) {\n    const value = record[key];\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true;\n      const list = /** @type {ReadonlyArray<unknown>} */value;\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true;\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false;\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  /** @type {PropertyValue} */\n  let result;\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return;\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = parseSpaces(value);\n    } else if (info.commaSeparated) {\n      result = parseCommas(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = parseSpaces(parseCommas(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value];\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = [];\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(/** @type {number | string} */\n      parsePrimitive(info, info.property, item));\n    }\n    result = finalResult;\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(/** @type {Array<number | string> | number | string} */result);\n  }\n  properties[info.property] = result;\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n  return value;\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} styles\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = [];\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '));\n  }\n  return result.join('; ');\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {ReadonlyArray<string>} values\n *   List of properly cased keys.\n * @returns {Map<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map();\n  for (const value of values) {\n    result.set(value.toLowerCase(), value);\n  }\n  return result;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}