{"ast":null,"code":"/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\nimport { h, s } from 'hastscript';\nimport { webNamespaces } from 'web-namespaces';\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nexport function fromDom(tree, options) {\n  return transform(tree, options || {}) || {\n    type: 'root',\n    children: []\n  };\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options);\n  if (transformed && options.afterTransform) options.afterTransform(node, transformed);\n  return transformed;\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */:\n      {\n        const domNode = /** @type {Element} */node;\n        return element(domNode, options);\n      }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */:\n      {\n        const domNode = /** @type {Text} */node;\n        return text(domNode);\n      }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */:\n      {\n        const domNode = /** @type {Comment} */node;\n        return comment(domNode);\n      }\n    case 9 /* Document */:\n      {\n        const domNode = /** @type {Document} */node;\n        return root(domNode, options);\n      }\n    case 10 /* Document type */:\n      {\n        return doctype();\n      }\n    case 11 /* Document fragment */:\n      {\n        const domNode = /** @type {DocumentFragment} */node;\n        return root(domNode, options);\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {\n    type: 'root',\n    children: all(node, options)\n  };\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {\n    type: 'doctype'\n  };\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {\n    type: 'text',\n    value: node.nodeValue || ''\n  };\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {\n    type: 'comment',\n    value: node.nodeValue || ''\n  };\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI;\n  const x = space === webNamespaces.svg ? s : h;\n  const tagName = space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName;\n  /** @type {DocumentFragment | Element} */\n  const content =\n  // @ts-expect-error: DOM types are wrong, content can exist.\n  space === webNamespaces.html && tagName === 'template' ? node.content : node;\n  const attributes = node.getAttributeNames();\n  /** @type {Record<string, string>} */\n  const properties = {};\n  let index = -1;\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || '';\n  }\n  return x(tagName, properties, all(content, options));\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes;\n  /** @type {Array<HastRootContent>} */\n  const children = [];\n  let index = -1;\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options);\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child);\n    }\n  }\n  return children;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}