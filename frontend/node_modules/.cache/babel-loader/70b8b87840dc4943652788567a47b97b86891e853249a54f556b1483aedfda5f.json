{"ast":null,"code":"/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\nimport { ok as assert } from 'devlop';\nimport { longestStreak } from 'longest-streak';\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {\n        className: ['language-math', 'math-display']\n      },\n      children: []\n    };\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'pre',\n        hChildren: [code]\n      }\n    }, token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'math');\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return;\n    this.buffer();\n    this.data.mathFlowInside = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'math');\n    this.exit(token);\n    node.value = data;\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */node.data.hChildren[0];\n    assert(code.type === 'element');\n    assert(code.tagName === 'code');\n    code.children.push({\n      type: 'text',\n      value: data\n    });\n    this.data.mathFlowInside = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'code',\n        hProperties: {\n          className: ['language-math', 'math-inline']\n        },\n        hChildren: []\n      }\n    }, token);\n    this.buffer();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    assert(node.type === 'inlineMath');\n    this.exit(token);\n    node.value = data;\n    const children = /** @type {Array<HastElementContent>} */\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    node.data.hChildren;\n    children.push({\n      type: 'text',\n      value: data\n    });\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath;\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '\\n',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      character: '$',\n      after: single ? undefined : '\\\\$',\n      inConstruct: 'phrasing'\n    }, {\n      character: '$',\n      inConstruct: 'mathFlowMeta'\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || '';\n    const tracker = state.createTracker(info);\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = state.enter('mathFlow');\n    let value = tracker.move(sequence);\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta');\n      value += tracker.move(state.safe(node.meta, {\n        after: '\\n',\n        before: value,\n        encode: ['$'],\n        ...tracker.current()\n      }));\n      subexit();\n    }\n    value += tracker.move('\\n');\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || '';\n    let size = 1;\n    if (!single) size++;\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    }\n    const sequence = '$'.repeat(size);\n\n    // If this is not just spaces or eols (tabs don’t count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n    // Contains non-space.\n    /[^ \\r\\n]/.test(value) && (\n    // Starts with space and ends with space.\n    /^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) ||\n    // Starts or ends with dollar.\n    /^\\$|\\$$/.test(value))) {\n      value = ' ' + value + ' ';\n    }\n    let index = -1;\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We can’t escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index];\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue;\n      const expression = state.compilePattern(pattern);\n      /** @type {RegExpExecArray | null} */\n      let match;\n      while (match = expression.exec(value)) {\n        let position = match.index;\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (value.codePointAt(position) === 10 /* `\\n` */ && value.codePointAt(position - 1) === 13 /* `\\r` */) {\n          position--;\n        }\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1);\n      }\n    }\n    return sequence + value + sequence;\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}