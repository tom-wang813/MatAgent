{"ast":null,"code":"export const sendMessage = async (message, conversationId, onNewStep) => {\n  const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000/api';\n  const traceId = `trace-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\n  try {\n    const response = await fetch(`${backendUrl}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Trace-ID': traceId\n      },\n      body: JSON.stringify({\n        message,\n        conversation_id: conversationId\n      })\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.detail || 'Failed to send message');\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    while (true) {\n      const {\n        value,\n        done\n      } = await reader.read();\n      if (done) break;\n      buffer += decoder.decode(value, {\n        stream: true\n      });\n      const lines = buffer.split('\\n');\n      buffer = lines.pop(); // Keep the last (potentially incomplete) line in the buffer\n\n      for (const line of lines) {\n        if (line.trim() === '') continue;\n        try {\n          const step = JSON.parse(line);\n          onNewStep(step);\n        } catch (e) {\n          console.error('Error parsing JSON stream chunk:', e, 'Chunk:', line);\n        }\n      }\n    }\n    // Process any remaining data in the buffer after the stream ends\n    if (buffer.trim() !== '') {\n      try {\n        const step = JSON.parse(buffer);\n        onNewStep(step);\n      } catch (e) {\n        console.error('Error parsing final JSON stream chunk:', e, 'Chunk:', buffer);\n      }\n    }\n  } catch (error) {\n    console.error('Error during streaming message:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["sendMessage","message","conversationId","onNewStep","backendUrl","process","env","REACT_APP_BACKEND_URL","traceId","Date","now","Math","random","toString","substring","response","fetch","method","headers","body","JSON","stringify","conversation_id","ok","errorData","json","Error","detail","reader","getReader","decoder","TextDecoder","buffer","value","done","read","decode","stream","lines","split","pop","line","trim","step","parse","e","console","error"],"sources":["/Users/wang-work/matagent/frontend/src/utils/api.js"],"sourcesContent":["export const sendMessage = async (message, conversationId, onNewStep) => {\n  const backendUrl = process.env.REACT_APP_BACKEND_URL || 'http://localhost:8000/api';\n  const traceId = `trace-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\n\n  try {\n    const response = await fetch(`${backendUrl}/chat`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Trace-ID': traceId,\n      },\n      body: JSON.stringify({\n        message,\n        conversation_id: conversationId,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.detail || 'Failed to send message');\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) break;\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n      buffer = lines.pop(); // Keep the last (potentially incomplete) line in the buffer\n\n      for (const line of lines) {\n        if (line.trim() === '') continue;\n        try {\n          const step = JSON.parse(line);\n          onNewStep(step);\n        } catch (e) {\n          console.error('Error parsing JSON stream chunk:', e, 'Chunk:', line);\n        }\n      }\n    }\n    // Process any remaining data in the buffer after the stream ends\n    if (buffer.trim() !== '') {\n      try {\n        const step = JSON.parse(buffer);\n        onNewStep(step);\n      } catch (e) {\n        console.error('Error parsing final JSON stream chunk:', e, 'Chunk:', buffer);\n      }\n    }\n\n  } catch (error) {\n    console.error('Error during streaming message:', error);\n    throw error;\n  }\n};\n"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,MAAAA,CAAOC,OAAO,EAAEC,cAAc,EAAEC,SAAS,KAAK;EACvE,MAAMC,UAAU,GAAGC,OAAO,CAACC,GAAG,CAACC,qBAAqB,IAAI,2BAA2B;EACnF,MAAMC,OAAO,GAAG,SAASC,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE;EAEpF,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGZ,UAAU,OAAO,EAAE;MACjDa,MAAM,EAAE,MAAM;MACdC,OAAO,EAAE;QACP,cAAc,EAAE,kBAAkB;QAClC,YAAY,EAAEV;MAChB,CAAC;MACDW,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QACnBpB,OAAO;QACPqB,eAAe,EAAEpB;MACnB,CAAC;IACH,CAAC,CAAC;IAEF,IAAI,CAACa,QAAQ,CAACQ,EAAE,EAAE;MAChB,MAAMC,SAAS,GAAG,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;MACvC,MAAM,IAAIC,KAAK,CAACF,SAAS,CAACG,MAAM,IAAI,wBAAwB,CAAC;IAC/D;IAEA,MAAMC,MAAM,GAAGb,QAAQ,CAACI,IAAI,CAACU,SAAS,CAAC,CAAC;IACxC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;IACjC,IAAIC,MAAM,GAAG,EAAE;IAEf,OAAO,IAAI,EAAE;MACX,MAAM;QAAEC,KAAK;QAAEC;MAAK,CAAC,GAAG,MAAMN,MAAM,CAACO,IAAI,CAAC,CAAC;MAC3C,IAAID,IAAI,EAAE;MAEVF,MAAM,IAAIF,OAAO,CAACM,MAAM,CAACH,KAAK,EAAE;QAAEI,MAAM,EAAE;MAAK,CAAC,CAAC;MACjD,MAAMC,KAAK,GAAGN,MAAM,CAACO,KAAK,CAAC,IAAI,CAAC;MAChCP,MAAM,GAAGM,KAAK,CAACE,GAAG,CAAC,CAAC,CAAC,CAAC;;MAEtB,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;QACxB,IAAIG,IAAI,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;QACxB,IAAI;UACF,MAAMC,IAAI,GAAGvB,IAAI,CAACwB,KAAK,CAACH,IAAI,CAAC;UAC7BtC,SAAS,CAACwC,IAAI,CAAC;QACjB,CAAC,CAAC,OAAOE,CAAC,EAAE;UACVC,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAEF,CAAC,EAAE,QAAQ,EAAEJ,IAAI,CAAC;QACtE;MACF;IACF;IACA;IACA,IAAIT,MAAM,CAACU,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MACxB,IAAI;QACF,MAAMC,IAAI,GAAGvB,IAAI,CAACwB,KAAK,CAACZ,MAAM,CAAC;QAC/B7B,SAAS,CAACwC,IAAI,CAAC;MACjB,CAAC,CAAC,OAAOE,CAAC,EAAE;QACVC,OAAO,CAACC,KAAK,CAAC,wCAAwC,EAAEF,CAAC,EAAE,QAAQ,EAAEb,MAAM,CAAC;MAC9E;IACF;EAEF,CAAC,CAAC,OAAOe,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,MAAMA,KAAK;EACb;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}